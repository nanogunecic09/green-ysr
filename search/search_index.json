{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"green-ysr The aim of this package is the calculation of the local density of states (LDOS) of magnetic impurities interacting with superconductors. The model is a standard Green function model able to deal with anisotropic Fermi surfaces. See this paper for details on the model and references. This is a basic tutorial to simulate local LDOS arbitrary impurity lattices interacting with a superconductor.","title":"Home"},{"location":"#green-ysr","text":"The aim of this package is the calculation of the local density of states (LDOS) of magnetic impurities interacting with superconductors. The model is a standard Green function model able to deal with anisotropic Fermi surfaces. See this paper for details on the model and references. This is a basic tutorial to simulate local LDOS arbitrary impurity lattices interacting with a superconductor.","title":"green-ysr"},{"location":"installation/","text":"The package is written in python and uses the standard libraries numpy, scipy, mpmath, matplotlib.. To install the package and its dependencies use the following command: pip install green-ysr","title":"Installation"},{"location":"reference/","text":"Reference class green_ysr.lattice(**kwargs) The atomic lattice to simulate. kwargs : type : string type of lattice, 'single atom', '1D' or '2D' N : int Number of atoms in the system coords : list in the case of a '2D' lattice, a list of the atomic coordinates must be provided pitch_x : float for a equi-spaced '1D' chain the pitch_x is the spacing of the atoms in the chain, needed to generate the coordinates direction : tuple direction of elongation of the chain in cristallographic notation, e.g. (1,0) is horizontal, (1,1) is 45 degrees alpha : float Adimensional exchange coupling parameter theta : float angle describing the orientation in rad of the classical spins U : float adimensional potential scattering parameter spiral : float if inserted is the pace of the spin spiral along the chain in radiants m : float effective mass multiplied by pi in atomic unit pf : float fermi momentum in atomic units delta : float superconducting order parameter in atomic units gamma : float dynes parameter in atomic units mode : int fermi surface dimensionality, 1 for circular, 2 for squared E_px : int point of energy to calculate E_range : tuple extremes of the energy, set 0,2 for calculate half of the spectrum V_range : tuple extremes of the voltage, used when doing the convolution spin_texture : list list of the spin orientation of the atoms in the structure, if not provided will be ferromagnetic Attributes: E : array energy array V : array voltage array, for convolution. The V range has to be always lower than E for the convolution. sim : class is the solver of the green function par : dict save all parameters coord_gen() for generating chain coordinates fiven the pitch return array of coordinates show_lattice() show the lattice coordinates in a plot map_coord_gen() generate the coordinate for a didv map Parameters : spac : float spacing in atomic units of the lattice resolution : int number of pixel in one line of the didv map size : int size of one side of the didv map in units of spac (spacing) show_lattice_map() show the lattice and the didv map coordinates in a plot didv() calculate the didv in one point Parameters : coord : tuple coordinates of the measurement point return array with spectra (normalized to normal conductance) didv_map_calc() caculates the didv map and store it in self.didv_map didv_conv() calculate the convolution with the superconducting tip at the temperature specified in self.T Parameters : coord : tuple coordinates of the measurement point Delta_t : float pairing amplitude in the tip electrode in meV Gamma_t : float dynes parameter in meV return array with tip convoluted spectra (normalized to normal conductance) linescan() compute a line of spectra (saved in self.LS) along the 1D chain direction, including initial and final portion of superconductor (pitch_x) Parameters : density : int number of points per atom in the linescan LSconvolute() compute the convoluted linescan (saved in self.LSC) at the temperature specified in self.T Parameters : coord : tuple coordinates of the measurement point Delta_t : float pairing amplitude of the tip electrode in meV Gamma_t : float Dynes parameter of the tip explorer() opens a slider plot to explore self.didv_map in constant energy cuts update_energy() vital to explorer() update_cscale() vital to explorer() class green_ysr.green(**kwargs) To calculate the green function. Parameters : N : int Number of atoms in the system alpha : float Adimensional exchange coupling parameter theta : float angle describing the orientation in rad of the classical spins r__ : list set of atomic coordinates U : float adimensional potential scattering parameter m : float effective mass multiplied by pi in atomic unit pf : float fermi momentum in atomic units delta : float superconducting order parameter in atomic units gamma : float dynes parameter in atomic units mode : int fermi surface dimensionality, 1 for circular, 2 for squared Attributes: s0-1-3 : numpy array pauli matrices G0() analitical form of the unperturbed green function V() Potential matrix of each impurity return a 4x4 matrix G0_() green function of the Dyson series return a 4x4N matrix G() full green function return a 4Nx4N matrix DOS() compute the spectrum of the green function ElecDOS() Compute the electron part of the spectral function ElecDOS() Compute the hole part of the spectral function Additional functions fdd() Fermi dirac distribution dynesdos() Dynes dos of a superconductor dynesConvolute() numerical convolution of a conducance array save_obj() save an arbitrary object load_obj() load an arbitrary object given its path without extension sim_save() to save a simulation, including important parameters in the name plot_LS() to show the result of a line of spectra calculated with lattice() set_size_cm() to change the size of a figure axis","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#class-green_ysrlatticekwargs","text":"The atomic lattice to simulate. kwargs : type : string type of lattice, 'single atom', '1D' or '2D' N : int Number of atoms in the system coords : list in the case of a '2D' lattice, a list of the atomic coordinates must be provided pitch_x : float for a equi-spaced '1D' chain the pitch_x is the spacing of the atoms in the chain, needed to generate the coordinates direction : tuple direction of elongation of the chain in cristallographic notation, e.g. (1,0) is horizontal, (1,1) is 45 degrees alpha : float Adimensional exchange coupling parameter theta : float angle describing the orientation in rad of the classical spins U : float adimensional potential scattering parameter spiral : float if inserted is the pace of the spin spiral along the chain in radiants m : float effective mass multiplied by pi in atomic unit pf : float fermi momentum in atomic units delta : float superconducting order parameter in atomic units gamma : float dynes parameter in atomic units mode : int fermi surface dimensionality, 1 for circular, 2 for squared E_px : int point of energy to calculate E_range : tuple extremes of the energy, set 0,2 for calculate half of the spectrum V_range : tuple extremes of the voltage, used when doing the convolution spin_texture : list list of the spin orientation of the atoms in the structure, if not provided will be ferromagnetic Attributes: E : array energy array V : array voltage array, for convolution. The V range has to be always lower than E for the convolution. sim : class is the solver of the green function par : dict save all parameters coord_gen() for generating chain coordinates fiven the pitch return array of coordinates show_lattice() show the lattice coordinates in a plot map_coord_gen() generate the coordinate for a didv map Parameters : spac : float spacing in atomic units of the lattice resolution : int number of pixel in one line of the didv map size : int size of one side of the didv map in units of spac (spacing) show_lattice_map() show the lattice and the didv map coordinates in a plot didv() calculate the didv in one point Parameters : coord : tuple coordinates of the measurement point return array with spectra (normalized to normal conductance) didv_map_calc() caculates the didv map and store it in self.didv_map didv_conv() calculate the convolution with the superconducting tip at the temperature specified in self.T Parameters : coord : tuple coordinates of the measurement point Delta_t : float pairing amplitude in the tip electrode in meV Gamma_t : float dynes parameter in meV return array with tip convoluted spectra (normalized to normal conductance) linescan() compute a line of spectra (saved in self.LS) along the 1D chain direction, including initial and final portion of superconductor (pitch_x) Parameters : density : int number of points per atom in the linescan LSconvolute() compute the convoluted linescan (saved in self.LSC) at the temperature specified in self.T Parameters : coord : tuple coordinates of the measurement point Delta_t : float pairing amplitude of the tip electrode in meV Gamma_t : float Dynes parameter of the tip explorer() opens a slider plot to explore self.didv_map in constant energy cuts update_energy() vital to explorer() update_cscale() vital to explorer()","title":"class green_ysr.lattice(**kwargs)"},{"location":"reference/#class-green_ysrgreenkwargs","text":"To calculate the green function. Parameters : N : int Number of atoms in the system alpha : float Adimensional exchange coupling parameter theta : float angle describing the orientation in rad of the classical spins r__ : list set of atomic coordinates U : float adimensional potential scattering parameter m : float effective mass multiplied by pi in atomic unit pf : float fermi momentum in atomic units delta : float superconducting order parameter in atomic units gamma : float dynes parameter in atomic units mode : int fermi surface dimensionality, 1 for circular, 2 for squared Attributes: s0-1-3 : numpy array pauli matrices G0() analitical form of the unperturbed green function V() Potential matrix of each impurity return a 4x4 matrix G0_() green function of the Dyson series return a 4x4N matrix G() full green function return a 4Nx4N matrix DOS() compute the spectrum of the green function ElecDOS() Compute the electron part of the spectral function ElecDOS() Compute the hole part of the spectral function","title":"class green_ysr.green(**kwargs)"},{"location":"reference/#additional-functions","text":"fdd() Fermi dirac distribution dynesdos() Dynes dos of a superconductor dynesConvolute() numerical convolution of a conducance array save_obj() save an arbitrary object load_obj() load an arbitrary object given its path without extension sim_save() to save a simulation, including important parameters in the name plot_LS() to show the result of a line of spectra calculated with lattice() set_size_cm() to change the size of a figure axis","title":"Additional functions"},{"location":"scripting/","text":"Scripting For quick start-up we follow with examples of LDOS calculations. After installation, import the package and matplotlib with: import green_ysr as gr import matplotlib.pyplot as plt Single atom Calculation of the surface BCS spectrum and a single classical spin impurity. Initialize the surface with: surface = gr.lattice(type='atom',alpha=0) Initialize the atom with: atom = gr.lattice(type='atom',alpha=0.05) In the last two codechunks alpha is the adimensional exchange coupling, 0 for the bare surface dos and finite for the atom. The rest of the arguments are implicit and can be modified if needed (see reference). To calculate the density of states: surface.didv([0,0]) where [0,0] is the position where the spectrum is measured. Plot of the result: plt.plot(surface.E*1e3,surface.didv([0,0])) plt.plot(atom.E*1e3,atom.didv([0,0])) # for cosmetics plt.xlabel('Energy (meV)') plt.ylabel('LDOS (Gn)') plt.xlim() gr.set_size_cm(8,5) plt.tight_layout() this should show the spectrum with the YSR resonance: To compute the convolution with a superconducting tip the didv_conv function is used instead: plt.plot(surface.V*1e3,surface.didv_conv([0,0])) plt.plot(atom.V*1e3,atom.didv_conv([0,0])) plt.xlabel('Energy (meV)') plt.ylabel('LDOS (Gn)') plt.tick_params(axis='both',direction='in') gr.set_size_cm(8,5) plt.tight_layout() this should produce this plot: Fermi surface anisotropy The Fermi surface contour shape can be set as circular, squared or hexagonal (mode=1,2,3 respectively). Next you find an example, the calculation of the LDOS at the YSR energy in the vicinity of one isolated impurity, with the three different Fermi surface contours. Initializing the simulation of a single atom with a circular contour (mode=0, default): atom = gr.lattice(type='atom',alpha=0.04,E_px=50,E_range=[0,2],mode=0) Calculation of the LDOS in squared grid (80x80 a0): atom.map_coord_gen(64,80) atom.didv_map_calc() the result is a 64x64x50 numpy ndarray stored in: atom.didv_map() a quick visualization of the result can be done with: atom.explorer() where the slider 'Energy cut' serves to plot the constant energy cuts of the 64x64 grid. For the squared and fermi contour, change the mode parameter to 2 and 3. For mode = 2, with the same commands you should see: For mode = 3 : In the next sections we will show examples on lattices with circular Fermi surface, but Dimer For a dimer we ser N=2 and the pitch_x as the distance between the two atoms in atomic units (Bohr radius). The atoms of the dimer have coordinates ([0,0],[0,8]). dimer = gr.lattice(N=2,type='1D',pitch_x=8,alpha=0.05) Doing the same calculation in [0,0] and plot you should see: A quick function to calculate the dos along the dimer axis is: dimer.linescan(3) That results in the even-odd superposition of YSR states. Saving results There is the possibility of saving and loading simulations. To save the dimer simulation above just add: gr.sim_save(dimer) this stores the result in the /out folder with an generated filename, containing information of the simulation. It can be loaded using: dimer = uf.load_obj(fname) where fname is the path of the saved file without extension. Chains The extension from dimers to chains is straightfarward, since one only needs to increment N and specify the chain direction: chain = gr.lattice(N=10,type='1D',pitch_x=6.3,alpha=0.07,U=0.07) The chain is 10 atoms along the horizontal direction with distance 6.3 a0. We introduced here a finite potential scattering U to better visualize the quantum well states. To compute a line of spectra along the chain: chain.linescan(5) with 5 the resolution, 5 spectra per atom. The result is stored in chain.LS and can be quicly visualized by: gr.plot_LS(chain) that results in: that you can save as explained above. Arbitrary lattice Arbitrary atomic lattices can be simulated given a set of coordinates. For example a cross with 5 atoms with coordinates: cross_coords = ( (0,0), (12.6,12.6), (-12.6,12.6), (12.6,-12.6), (-12.6,-12.6), ) To initialize the calculation: cross = gr.lattice(type='2D',N=5,coords=cross_coords,alpha=0.04,E_px=50,E_range=[0,2]) where we limited the energy points and range (didv is simmetric since particle-hole simmetry). The .didv method can be used to calculate the LDOS in specific points (see above). To calculate the DOS in a squared grid around the structure (50.4x50.4 a0), first generate the grid points: cross.map_coord_gen(28,50.4) cross.show_lattice_map() the second command with show the lattice toghether with the LDOS map points: The first input is the spacing of the structure along x, the second is the number of pixel per line and the third is the lateral size of the map in units of the spacing. To run the calculation and save it afterwards: cross.didv_map_calc() gr.sim_save(cross) The DOS map is stored in cross.didv_map, and can be easily visualized with a built in function: cross.explorer() that will show a slider based viewer:","title":"Scripting"},{"location":"scripting/#scripting","text":"For quick start-up we follow with examples of LDOS calculations. After installation, import the package and matplotlib with: import green_ysr as gr import matplotlib.pyplot as plt","title":"Scripting"},{"location":"scripting/#single-atom","text":"Calculation of the surface BCS spectrum and a single classical spin impurity. Initialize the surface with: surface = gr.lattice(type='atom',alpha=0) Initialize the atom with: atom = gr.lattice(type='atom',alpha=0.05) In the last two codechunks alpha is the adimensional exchange coupling, 0 for the bare surface dos and finite for the atom. The rest of the arguments are implicit and can be modified if needed (see reference). To calculate the density of states: surface.didv([0,0]) where [0,0] is the position where the spectrum is measured. Plot of the result: plt.plot(surface.E*1e3,surface.didv([0,0])) plt.plot(atom.E*1e3,atom.didv([0,0])) # for cosmetics plt.xlabel('Energy (meV)') plt.ylabel('LDOS (Gn)') plt.xlim() gr.set_size_cm(8,5) plt.tight_layout() this should show the spectrum with the YSR resonance: To compute the convolution with a superconducting tip the didv_conv function is used instead: plt.plot(surface.V*1e3,surface.didv_conv([0,0])) plt.plot(atom.V*1e3,atom.didv_conv([0,0])) plt.xlabel('Energy (meV)') plt.ylabel('LDOS (Gn)') plt.tick_params(axis='both',direction='in') gr.set_size_cm(8,5) plt.tight_layout() this should produce this plot:","title":"Single atom"},{"location":"scripting/#fermi-surface-anisotropy","text":"The Fermi surface contour shape can be set as circular, squared or hexagonal (mode=1,2,3 respectively). Next you find an example, the calculation of the LDOS at the YSR energy in the vicinity of one isolated impurity, with the three different Fermi surface contours. Initializing the simulation of a single atom with a circular contour (mode=0, default): atom = gr.lattice(type='atom',alpha=0.04,E_px=50,E_range=[0,2],mode=0) Calculation of the LDOS in squared grid (80x80 a0): atom.map_coord_gen(64,80) atom.didv_map_calc() the result is a 64x64x50 numpy ndarray stored in: atom.didv_map() a quick visualization of the result can be done with: atom.explorer() where the slider 'Energy cut' serves to plot the constant energy cuts of the 64x64 grid. For the squared and fermi contour, change the mode parameter to 2 and 3. For mode = 2, with the same commands you should see: For mode = 3 : In the next sections we will show examples on lattices with circular Fermi surface, but","title":"Fermi surface anisotropy"},{"location":"scripting/#dimer","text":"For a dimer we ser N=2 and the pitch_x as the distance between the two atoms in atomic units (Bohr radius). The atoms of the dimer have coordinates ([0,0],[0,8]). dimer = gr.lattice(N=2,type='1D',pitch_x=8,alpha=0.05) Doing the same calculation in [0,0] and plot you should see: A quick function to calculate the dos along the dimer axis is: dimer.linescan(3) That results in the even-odd superposition of YSR states.","title":"Dimer"},{"location":"scripting/#saving-results","text":"There is the possibility of saving and loading simulations. To save the dimer simulation above just add: gr.sim_save(dimer) this stores the result in the /out folder with an generated filename, containing information of the simulation. It can be loaded using: dimer = uf.load_obj(fname) where fname is the path of the saved file without extension.","title":"Saving results"},{"location":"scripting/#chains","text":"The extension from dimers to chains is straightfarward, since one only needs to increment N and specify the chain direction: chain = gr.lattice(N=10,type='1D',pitch_x=6.3,alpha=0.07,U=0.07) The chain is 10 atoms along the horizontal direction with distance 6.3 a0. We introduced here a finite potential scattering U to better visualize the quantum well states. To compute a line of spectra along the chain: chain.linescan(5) with 5 the resolution, 5 spectra per atom. The result is stored in chain.LS and can be quicly visualized by: gr.plot_LS(chain) that results in: that you can save as explained above.","title":"Chains"},{"location":"scripting/#arbitrary-lattice","text":"Arbitrary atomic lattices can be simulated given a set of coordinates. For example a cross with 5 atoms with coordinates: cross_coords = ( (0,0), (12.6,12.6), (-12.6,12.6), (12.6,-12.6), (-12.6,-12.6), ) To initialize the calculation: cross = gr.lattice(type='2D',N=5,coords=cross_coords,alpha=0.04,E_px=50,E_range=[0,2]) where we limited the energy points and range (didv is simmetric since particle-hole simmetry). The .didv method can be used to calculate the LDOS in specific points (see above). To calculate the DOS in a squared grid around the structure (50.4x50.4 a0), first generate the grid points: cross.map_coord_gen(28,50.4) cross.show_lattice_map() the second command with show the lattice toghether with the LDOS map points: The first input is the spacing of the structure along x, the second is the number of pixel per line and the third is the lateral size of the map in units of the spacing. To run the calculation and save it afterwards: cross.didv_map_calc() gr.sim_save(cross) The DOS map is stored in cross.didv_map, and can be easily visualized with a built in function: cross.explorer() that will show a slider based viewer:","title":"Arbitrary lattice"}]}